#include "rules/1125_redundant_boolean.dl"
#include "rules/1132_string_literals_left_side.dl"
#include "rules/1153_remove_valueof_on_string_append.dl"
#include "rules/1155_use_isempty.dl"
#include "rules/1217_dont_call_thread_run.dl"
#include "rules/1481_unused_local_variables.dl"
#include "rules/1764_identical_expressions_binary_operator.dl"
#include "rules/1596_fix_old_empty_collection.dl"
#include "rules/1602_lambda_single_statement.dl"
#include "rules/2095_close_resources.dl"
#include "rules/2111_bigdecimal_double.dl"
#include "rules/2121_fix_silly_string_operations.dl"
#include "rules/2159_fix_silly_equality_checks.dl"
#include "rules/2225_tostring_and_clone_should_not_return_null.dl"
#include "rules/2259_dont_dereference_null_pointers.dl"
#include "rules/2272_throw_nosuchelementexception.dl"
#include "rules/3824_replace_map_get.dl"
#include "rules/4973_use_equals_method.dl"

#include "nodes.dl"


/* Types
 ********************************/

.type id = [type: symbol, filename: symbol, from: number, to: number]
.type id_list = [head: id, tail: id_list]
.type symbol_list = [head: symbol, tail: symbol_list]

/* Tokens
 ********************************/

.decl token(str: symbol, from: number, to: number)
.input token

/* AST nodes
 ********************************/

.decl root(id: id)
.input root
.output root(IO=stdout)

.decl ast_node(id: id)
ast_node(id) :- root(id).
ast_node(child) :- ast_node(ancestor), ancestor_of(ancestor, child).

.decl filename_of(id: id, filename: symbol)
filename_of([name, fn, A, B], fn) :- ast_node([name, fn, A, B]).

.decl name_of(id: id, name: symbol)
name_of([name, fn, A, B], name) :- ast_node([name, fn, A, B]).

.decl starts_at(id: id, at: number)
starts_at([name, fn, A, B], A) :- ast_node([name, fn, A, B]).

.decl ends_at(id: id, at: number)
ends_at([name, fn, A, B], B) :- ast_node([name, fn, A, B]).

/* AST node relations
 ********************************/

.decl parent_of(parent: id, name: symbol, child: id)
.input parent_of

.decl parent_of_list(parent: id, name: symbol, children: id_list)
.input parent_of_list

/* transitive closure of parent_of and parent_of list */
.decl ancestor_of(ancestor: id, child: id)
ancestor_of(x, y) :-
    parent_of(x, _, y).
ancestor_of(x, z) :-
    ancestor_of(x, y),
    parent_of(y, _, z).
ancestor_of(x, y) :-
    parent_of_list(x, _, children),
    list_contains(children, y).
ancestor_of(x, z) :-
    ancestor_of(x, y),
    parent_of_list(y, _, children),
    list_contains(children, z).

.decl head_of(head: id, tail: id_list)
head_of(head, tail) :-
    parent_of_list(_, _, [head, tail]).
head_of(head, tail) :-
    head_of(_, [head, tail]).

/* is x at the position just before y in a list? */
.decl predecessor_of(x: id, y: id)
predecessor_of(x, y) :-
    head_of(x, [y, _]).

/* transitive closure of predecessor_of */
.decl precedes(x: id, y: id)
precedes(x, y) :-
    predecessor_of(x, y).
precedes(x, z) :-
    precedes(x, y),
    predecessor_of(y, z).

/* does the list contain the element? */
.decl list_contains(list: id_list, id: id)
list_contains([head,tail], head) :-
    parent_of_list(_, _, [head, tail]).
list_contains(list, b) :-
    list_contains(list, a),
    predecessor_of(a, b).

/* Common AST patterns
 ********************************/

.decl not_equals_null_expression(id: id, subject: id)
not_equals_null_expression(id, subject) :-
    not_equals_expression(id, _, _),
    parent_of(id, _, subject),
    parent_of(id, _, null),
    string_representation(null, "null"),
    subject != null.

/* Constant evaluation
 ********************************/

.decl evaluates_to_integer_value(id: id, value: number)
evaluates_to_integer_value(id, 0) :-
    integer_literal(id),
    string_representation(id, "0").
evaluates_to_integer_value(id, 1) :-
    integer_literal(id),
    string_representation(id, "1").
/* TODO
evaluates_to_integer_value(id, to_number(repr)) :-
    integer_literal(id),
    string_representation(id, repr).
*/
evaluates_to_integer_value(id, left_value + right_value) :-
    addition_expression(id, left, right),
    evaluates_to_integer_value(left, left_value),
    evaluates_to_integer_value(right, right_value).
evaluates_to_integer_value(id, left_value * right_value) :-
    multiplication_expression(id, left, right),
    evaluates_to_integer_value(left, left_value),
    evaluates_to_integer_value(right, right_value).
evaluates_to_integer_value(id, left_value - right_value) :-
    subtraction_expression(id, left, right),
    evaluates_to_integer_value(left, left_value),
    evaluates_to_integer_value(right, right_value).

.decl evaluates_to_boolean_value(id: id, value: number)
evaluates_to_boolean_value(id, 0) :-
    string_representation(id, "false").
evaluates_to_boolean_value(id, 1) :-
    string_representation(id, "true").
evaluates_to_boolean_value(id, left_value land right_value) :-
    conditional_and_expression(id, left, right),
    evaluates_to_boolean_value(left, left_value),
    evaluates_to_boolean_value(right, right_value).
evaluates_to_boolean_value(id, left_value lor right_value) :-
    conditional_or_expression(id, left, right),
    evaluates_to_boolean_value(left, left_value),
    evaluates_to_boolean_value(right, right_value).
evaluates_to_boolean_value(id, 1) :-
    equals_expression(id, left, right),
    evaluates_to_integer_value(left, x),
    evaluates_to_integer_value(right, x).
evaluates_to_boolean_value(id, 0) :-
    equals_expression(id, left, right),
    evaluates_to_integer_value(left, x),
    evaluates_to_integer_value(right, y),
    x != y.

/* String representation
 ********************************/

.decl source_code(filename: symbol, str: symbol)
.input source_code

.decl string_representation(id: id, str: symbol)
string_representation([name, filename, A, B], substr(code, A, B - A)) :-
    ast_node([name, filename, A, B]),
    source_code(filename, code).

/* Variable scope
 ********************************/

/**
 * The scope of a local variable declaration in a block (ยง14.2) is the rest of
 * the block in which the declaration appears, starting with its own
 * initializer (ยง14.4) and including any further declarators to the right in
 * the local variable declaration statement.
 * https://docs.oracle.com/javase/specs/jls/se6/html/statements.html
 */

.decl in_scope(position: id, identifier: symbol, type: id)
.output in_scope

/* Scope of variables is transitive (TODO: lambda is a special case?) */
in_scope(descendant, identifier, type) :-
    in_scope(ancestor, identifier, type),
    ancestor_of(ancestor, descendant).

/* Make parameter in enhanced for statement accessible in its body */
in_scope(body, identifier_str, param) :-
    ast_node(stmt),
    name_of(stmt, "enhanced_for_statement"),
    parent_of(stmt, "param", param),
    formal_parameter(param, _, _, identifier),
    string_representation(identifier, identifier_str),
    parent_of(stmt, "statement", body).

/* Make field declarations in scope in the method bodies of their class */
in_scope(method_body, identifier_str, field) :-
    class_declaration(_, _, _, _, _, class_body),
    /* declared_at */
    list_contains(class_body, field),
    field_declaration(field, _, _, declarators),
    list_contains(declarators, declarator),
    variable_declarator(declarator, identifier, _),
    string_representation(identifier, identifier_str),
    /* available at */
    list_contains(class_body, method),
    method_declaration(method, _, _, method_body).

/* Make field declarations in scope in the constructor bodies of their class */
in_scope(constructor_body, identifier_str, field) :-
    class_declaration(_, _, _, _, _, class_body),
    /* declared_at */
    list_contains(class_body, field),
    field_declaration(field, _, _, declarators),
    list_contains(declarators, declarator),
    variable_declarator(declarator, identifier, _),
    string_representation(identifier, identifier_str),
    /* available at */
    list_contains(class_body, constructor),
    constructor_declaration(constructor, _, _, _, constructor_body).

/* Make formal parameters accessible in the body of a method */
in_scope(body, identifier_str, param) :-
    method_declaration(_, _, header, body),
    method_header(header, _, declarator, _),
    parent_of_list(declarator, "params", params),
    list_contains(params, param),
    formal_parameter(param, _, _, identifier),
    string_representation(identifier, identifier_str).

/* Make formal parameters accessible in the body of a constructor */
in_scope(body, identifier_str, param) :-
    constructor_declaration(_, _, declarator, _, body),
    parent_of_list(declarator, "params", params),
    list_contains(params, param),
    formal_parameter(param, _, _, identifier),
    string_representation(identifier, identifier_str).

/* Make local variable declarations accessible in the succeeding statements */
in_scope(succeeding_statement, identifier_str, declaration) :-
    local_variable_declaration_statement(declaration_statement, declaration),
    local_variable_declaration(declaration, _, _, declarators),
    precedes(declaration_statement, succeeding_statement),
    list_contains(declarators, declarator),
    variable_declarator(declarator, identifier, _),
    string_representation(identifier, identifier_str).

/* Point of declaration
 ********************************/

.decl has_formal_parameter_or_local_var_decl_in_scope(id: id)
has_formal_parameter_or_local_var_decl_in_scope(id) :-
    expression_name(id, [head, _]),
    in_scope(id, identifier, decl),
    local_variable_declaration(decl, _, _, _),
    string_representation(head, identifier).
has_formal_parameter_or_local_var_decl_in_scope(id) :-
    expression_name(id, [head, _]),
    in_scope(id, identifier, decl),
    formal_parameter(decl, _, _, _),
    string_representation(head, identifier).

.decl point_of_declaration(id: id, declaration: id)
.output point_of_declaration(IO=stdout)
/* If there is a local variable declaration or a formal parameter in scope,
   the identifier definitely refers to it (these can't be shadowed) */
point_of_declaration(head, decl) :-
    expression_name(id, [head, _]),
    in_scope(id, identifier, decl),
    local_variable_declaration(decl, _, _, _),
    string_representation(head, identifier).
point_of_declaration(head, decl) :-
    expression_name(id, [head, _]),
    in_scope(id, identifier, decl),
    formal_parameter(decl, _, _, _),
    string_representation(head, identifier).
/* If there is no local variable declarations of formal parameters in scope
   the identifier refers to the field */
point_of_declaration(head, decl) :-
    expression_name(id, [head, _]),
    in_scope(id, identifier, decl),
    string_representation(head, identifier),
    field_declaration(decl, _, _, _),
    ! has_formal_parameter_or_local_var_decl_in_scope(id).

/* We can always refer to the field of the class using "this" */
point_of_declaration(id, type) :-
    field_access(id, this, field),
    name_of(this, "this_expression"),
    in_scope(id, identifier, type),
    string_representation(field, identifier).

/* If an expression name contains only one identifier then the whole
   expression refers to its identifier */
point_of_declaration(id, decl) :-
    expression_name(id, [head, nil]),
    point_of_declaration(head, decl).

/* Types of variable references
 ********************************/

.decl has_type(id: id, type: id)
has_type(id, type) :-
    point_of_declaration(id, declpoint),
    parent_of(declpoint, "type", type).
/* If an expression_name only has one identifier, then the expression_name has the same
   type as the identifier */
has_type(exprname, type) :-
    expression_name(exprname, [head, nil]),
    has_type(head, type).

/* Type checking
 ********************************/

.decl collection_type_name(str: symbol)
collection_type_name("ArrayList").
collection_type_name("Collection").
collection_type_name("Deque").
collection_type_name("LinkedList").
collection_type_name("List").
collection_type_name("Queue").
collection_type_name("Set").
collection_type_name("Map"). // TODO not technically true
collection_type_name("LinkedHashMap"). // TODO not technically true
collection_type_name("SortedSet").
collection_type_name("Stack").
collection_type_name("Vector").

.decl floating_point_type_name(str: symbol)
floating_point_type_name("float").
floating_point_type_name("double").

.decl atomic_class_type_name(str: symbol)
atomic_class_type_name("AtomicInteger").
atomic_class_type_name("AtomicBoolean").
atomic_class_type_name("AtomicLong").

.decl boxed_type_name(str: symbol)
boxed_type_name("Boolean").
boxed_type_name("Byte").
boxed_type_name("Character").
boxed_type_name("Float").
boxed_type_name("Integer").
boxed_type_name("Long").
boxed_type_name("Short").
boxed_type_name("Double").

/* list of resources that implements the AutoCloseable interface */
.decl autocloseable_type_name(str: symbol)
autocloseable_type_name("AbstractInterruptibleChannel").
autocloseable_type_name("AbstractSelectableChannel").
autocloseable_type_name("AbstractSelector").
autocloseable_type_name("AsynchronousFileChannel").
autocloseable_type_name("AsynchronousServerSocketChannel").
autocloseable_type_name("AsynchronousSocketChannel").
autocloseable_type_name("AudioInputStream").
autocloseable_type_name("BufferedInputStream").
autocloseable_type_name("BufferedOutputStream").
autocloseable_type_name("BufferedReader").
autocloseable_type_name("BufferedWriter").
autocloseable_type_name("ByteArrayInputStream").
autocloseable_type_name("ByteArrayOutputStream").
autocloseable_type_name("CharArrayReader").
autocloseable_type_name("CharArrayWriter").
autocloseable_type_name("CheckedInputStream").
autocloseable_type_name("CheckedOutputStream").
autocloseable_type_name("CipherInputStream").
autocloseable_type_name("CipherOutputStream").
autocloseable_type_name("DatagramChannel").
autocloseable_type_name("DatagramSocket").
autocloseable_type_name("DataInputStream").
autocloseable_type_name("DataOutputStream").
autocloseable_type_name("DeflaterInputStream").
autocloseable_type_name("DeflaterOutputStream").
autocloseable_type_name("DigestInputStream").
autocloseable_type_name("DigestOutputStream").
autocloseable_type_name("FileCacheImageInputStream").
autocloseable_type_name("FileCacheImageOutputStream").
autocloseable_type_name("FileChannel").
autocloseable_type_name("FileImageInputStream").
autocloseable_type_name("FileImageOutputStream").
autocloseable_type_name("FileInputStream").
autocloseable_type_name("FileLock").
autocloseable_type_name("FileOutputStream").
autocloseable_type_name("FileReader").
autocloseable_type_name("FileSystem").
autocloseable_type_name("FileWriter").
autocloseable_type_name("FilterInputStream").
autocloseable_type_name("FilterOutputStream").
autocloseable_type_name("FilterReader").
autocloseable_type_name("FilterWriter").
autocloseable_type_name("Formatter").
autocloseable_type_name("ForwardingJavaFileManager").
autocloseable_type_name("GZIPInputStream").
autocloseable_type_name("GZIPOutputStream").
autocloseable_type_name("ImageInputStreamImpl").
autocloseable_type_name("ImageOutputStreamImpl").
autocloseable_type_name("InflaterInputStream").
autocloseable_type_name("InflaterOutputStream").
autocloseable_type_name("InputStream").
autocloseable_type_name("InputStream").
autocloseable_type_name("InputStream").
autocloseable_type_name("InputStreamReader").
autocloseable_type_name("JarFile").
autocloseable_type_name("JarInputStream").
autocloseable_type_name("JarOutputStream").
autocloseable_type_name("LineNumberInputStream").
autocloseable_type_name("LineNumberReader").
autocloseable_type_name("LogStream").
autocloseable_type_name("MemoryCacheImageInputStream").
autocloseable_type_name("MemoryCacheImageOutputStream").
autocloseable_type_name("MLet").
autocloseable_type_name("MulticastSocket").
autocloseable_type_name("ObjectInputStream").
autocloseable_type_name("ObjectOutputStream").
autocloseable_type_name("OutputStream").
autocloseable_type_name("OutputStream").
autocloseable_type_name("OutputStream").
autocloseable_type_name("OutputStreamWriter").
autocloseable_type_name("Pipe.SinkChannel").
autocloseable_type_name("Pipe.SourceChannel").
autocloseable_type_name("PipedInputStream").
autocloseable_type_name("PipedOutputStream").
autocloseable_type_name("PipedReader").
autocloseable_type_name("PipedWriter").
autocloseable_type_name("PrintStream").
autocloseable_type_name("PrintWriter").
autocloseable_type_name("PrivateMLet").
autocloseable_type_name("ProgressMonitorInputStream").
autocloseable_type_name("PushbackInputStream").
autocloseable_type_name("PushbackReader").
autocloseable_type_name("RandomAccessFile").
autocloseable_type_name("Reader").
autocloseable_type_name("RMIConnectionImpl").
autocloseable_type_name("RMIConnectionImpl_Stub").
autocloseable_type_name("RMIConnector").
autocloseable_type_name("RMIIIOPServerImpl").
autocloseable_type_name("RMIJRMPServerImpl").
autocloseable_type_name("RMIServerImpl").
autocloseable_type_name("Scanner").
autocloseable_type_name("SelectableChannel").
autocloseable_type_name("Selector").
autocloseable_type_name("SequenceInputStream").
autocloseable_type_name("ServerSocket").
autocloseable_type_name("ServerSocketChannel").
autocloseable_type_name("Socket").
autocloseable_type_name("SocketChannel").
autocloseable_type_name("SSLServerSocket").
autocloseable_type_name("SSLSocket").
autocloseable_type_name("StringBufferInputStream").
autocloseable_type_name("StringReader").
autocloseable_type_name("StringWriter").
autocloseable_type_name("URLClassLoader").
autocloseable_type_name("Writer").
autocloseable_type_name("XMLDecoder").
autocloseable_type_name("XMLEncoder").
autocloseable_type_name("ZipFile").
autocloseable_type_name("ZipInputStream").
autocloseable_type_name("ZipOutputStream").

/* Is type */

.decl is_collection_type(id: id)
is_collection_type(id) :-
    // TODO: Should take imports into consideration?
    class_type(id, name, _, _),
    string_representation(name, name_str),
    collection_type_name(name_str).

.decl is_exception_type(id: id)
is_exception_type(id) :-
    class_type(id, name, _, _),
    string_representation(name, name_str),
    match(".*Exception", name_str).

.decl is_string_type(id: id)
is_string_type(id) :-
    class_type(id, name, _, _),
    string_representation(name, "String").

.decl is_boxed_type(id: id)
is_boxed_type(id) :-
    class_type(id, name, _, _),
    string_representation(name, name_str),
    boxed_type_name(name_str).

.decl is_autocloseable_type(id: id)
is_autocloseable_type(id) :-
    class_type(id, name, _, _),
    string_representation(name, name_str),
    autocloseable_type_name(name_str).

.decl is_floating_point_type(id: id)
is_floating_point_type(id) :-
    primitive_type(id, _, name),
    string_representation(name, name_str),
    floating_point_type_name(name_str).

.decl is_atomic_class_type(id: id)
is_atomic_class_type(id) :-
    class_type(id, name, _, _),
    string_representation(name, name_str),
    atomic_class_type_name(name_str).

.decl is_thread_type(id: id)
is_thread_type(id) :-
    class_type(id, name, _, _),
    string_representation(name, "Thread").

.decl has_floating_point_type(id: id)
has_floating_point_type(id) :- floating_point_literal(id).
has_floating_point_type(id) :- has_type(id, type), is_floating_point_type(type).
has_floating_point_type(id) :-
    multiplication_expression(id, left, right),
    has_floating_point_type(left),
    has_floating_point_type(right).

.decl has_autocloseable_type(id: id)
has_autocloseable_type(id) :- has_type(id, type), is_autocloseable_type(type).

.decl has_thread_type(id: id)
has_thread_type(id) :- has_type(id, type), is_thread_type(type).

.decl has_string_type(id: id)
has_string_type(id) :- string_literal(id).
has_string_type(id) :- has_type(id, type), is_string_type(type).

.decl has_string_or_boxed_type(id: id)
has_string_or_boxed_type(id) :- has_type(id, type), is_boxed_type(type).
has_string_or_boxed_type(id) :- has_string_type(id).

.decl has_collection_type(id: id)
has_collection_type(id) :- has_type(id, type), is_collection_type(type).

.decl has_atomic_class_type(id: id)
has_atomic_class_type(id) :- has_type(id, type), is_atomic_class_type(type).

/* Syntax
 ********************************/

/**
 * True for all nodes where parenthesization could change the meaning of a compound expression.
 */
.decl has_semantic_parenthesization(id: id)
has_semantic_parenthesization(id) :- lambda_expression(id, _, _).
has_semantic_parenthesization(id) :- conditional_expression(id, _, _, _).
has_semantic_parenthesization(id) :- conditional_or_expression(id, _, _).
has_semantic_parenthesization(id) :- conditional_and_expression(id, _, _).
has_semantic_parenthesization(id) :- inclusive_or_expression(id, _, _).
has_semantic_parenthesization(id) :- exclusive_or_expression(id, _, _).
has_semantic_parenthesization(id) :- equals_expression(id, _, _).
has_semantic_parenthesization(id) :- not_equals_expression(id, _, _).
has_semantic_parenthesization(id) :- less_than_expression(id, _, _).
has_semantic_parenthesization(id) :- greater_than_expression(id, _, _).
has_semantic_parenthesization(id) :- less_than_or_equals_expression(id, _, _).
has_semantic_parenthesization(id) :- greater_than_or_equals_expression(id, _, _).
has_semantic_parenthesization(id) :- instanceof_expression(id, _, _).
has_semantic_parenthesization(id) :- signed_left_shift_expression(id, _, _).
has_semantic_parenthesization(id) :- signed_right_shift_expression(id, _, _).
has_semantic_parenthesization(id) :- unsigned_right_shift_expression(id, _, _).
has_semantic_parenthesization(id) :- addition_expression(id, _, _).
has_semantic_parenthesization(id) :- subtraction_expression(id, _, _).
has_semantic_parenthesization(id) :- multiplication_expression(id, _, _).
has_semantic_parenthesization(id) :- division_expression(id, _, _).
has_semantic_parenthesization(id) :- remainder_expression(id, _, _).

.decl string_representation_with_parentheses(id: id, str: symbol)
string_representation_with_parentheses(id, id_str) :-
    ! has_semantic_parenthesization(id),
    string_representation(id, id_str).
string_representation_with_parentheses(id, cat("(", id_str, ")")) :-
    has_semantic_parenthesization(id),
    string_representation(id, id_str).


/* Rewrite rules
 ********************************/

.decl rewrite(rule: number, filename: symbol, from: id, to: symbol)
.output rewrite(IO=stdout)
