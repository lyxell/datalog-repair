# vim: set filetype=prolog:

/* Types
 ********************************/

.type id = [type: symbol, from: number, to: number]
.type id_list = [head: id, tail: id_list]
.type symbol_list = [head: symbol, tail: symbol_list]

/* Tokens
 ********************************/

.decl token(str: symbol, from: number, to: number)
.input token

/* AST nodes
 ********************************/

.decl root(id: id)
.input root
.output root(IO=stdout)

.decl ast_node(id: id)
ast_node(id) :- root(id).
ast_node(child) :- ast_node(ancestor), ancestor_of(ancestor, child).

.decl name_of(id: id, name: symbol)
name_of([name, A, B], name) :- ast_node([name, A, B]).

.decl starts_at(id: id, at: number)
starts_at([name, A, B], A) :- ast_node([name, A, B]).

.decl ends_at(id: id, at: number)
ends_at([name, A, B], B) :- ast_node([name, A, B]).

/* AST node relations
 ********************************/

.decl parent_of(parent: id, name: symbol, child: id)
.input parent_of

.decl parent_of_list(parent: id, name: symbol, children: id_list)
.input parent_of_list

.decl is_superlist_of(superlist: id_list, list: id_list)
is_superlist_of(list, list) :-
    parent_of_list(_, _, list).
is_superlist_of(list, tail) :-
    is_superlist_of(list, [_, tail]).

.decl list_contains(list: id_list, id: id)
list_contains(superlist, head) :-
    is_superlist_of(superlist, [head, _]).

/* ancestor_of is the transitive closure of parent_of and parent_of list */
.decl ancestor_of(ancestor: id, child: id)
ancestor_of(x, y) :-
    parent_of(x, _, y).
ancestor_of(x, z) :-
    ancestor_of(x, y),
    parent_of(y, _, z).
ancestor_of(x, y) :-
    parent_of_list(x, _, children),
    list_contains(children, y).
ancestor_of(x, z) :-
    ancestor_of(x, y),
    parent_of_list(y, _, children),
    list_contains(children, z).

.decl head_of(head: id, tail: id_list)
head_of(head, tail) :-
    parent_of_list(_, _, [head, tail]).
head_of(head, tail) :-
    head_of(_, [head, tail]).

.decl predecessor_of(x: id, y: id)
predecessor_of(x, y) :-
    head_of(x, [y, _]).

.decl precedes(x: id, y: id)
precedes(x, y) :-
    predecessor_of(x, y).
precedes(x, z) :-
    precedes(x, y),
    predecessor_of(y, z).

/* AST node types
 ********************************/

.decl throw_statement(id: id, expr: id)
throw_statement(id, expr) :-
    name_of(id, "throw_statement"),
    parent_of(id, "expression", expr).

.decl expression_statement(id: id, expr: id)
expression_statement(id, expr) :-
    name_of(id, "expression_statement"),
    parent_of(id, "expression", expr).

#define INFIX(name) \
    .decl name(id: id, left: id, right: id) \
    name(id, left, right) :- \
        name_of(id, #name), \
        parent_of(id, "left", left), \
        parent_of(id, "right", right).

INFIX(not_equals_expression)
INFIX(equals_expression)
INFIX(conditional_and_expression)
INFIX(conditional_or_expression)
INFIX(greater_than_expression)
INFIX(addition_expression)
INFIX(subtraction_expression)
INFIX(multiplication_expression)

.decl class_declaration(id: id, modifiers: id_list, name: id, superclass: id, superinterfaces: id_list, body: id_list)
class_declaration(id, mods, name, superclass, superinterfaces, body) :-
    name_of(id, "class_declaration"),
    parent_of_list(id, "modifiers", mods),
    parent_of(id, "name", name),
    parent_of(id, "superclass", superclass),
    parent_of_list(id, "superinterfaces", superinterfaces),
    parent_of_list(id, "body", body).

.decl field_declaration(id: id, modifiers: id_list, type: id, declarators: id_list)
field_declaration(id, mods, type, declarators) :-
    name_of(id, "field_declaration"),
    parent_of_list(id, "modifiers", mods),
    parent_of(id, "type", type),
    parent_of_list(id, "declarators", declarators).

.decl method_declaration(id: id, modifiers: id_list, header: id, body: id)
method_declaration(id, mods, header, body) :-
    name_of(id, "method_declaration"),
    parent_of(id, "header", header),
    parent_of_list(id, "modifiers", mods),
    parent_of(id, "body", body).

.decl method_header(id: id, result: id, declarator: id, throws: id)
method_header(id, result, declarator, throws) :-
    name_of(id, "method_header"),
    parent_of(id, "result", result),
    parent_of(id, "declarator", declarator),
    parent_of(id, "throws", throws).


.decl method_invocation(id: id, subject: id, method: id, arguments: id_list)
method_invocation(id, subject, method, arguments) :-
    name_of(id, "method_invocation"),
    parent_of(id, "subject", subject),
    parent_of(id, "method", method),
    parent_of_list(id, "arguments", arguments).

.decl formal_parameter(id: id, modifiers: id_list, type: id, name: id)
formal_parameter(id, modifiers, type, name) :-
    name_of(id, "formal_parameter"),
    parent_of_list(id, "modifiers", modifiers),
    parent_of(id, "type", type),
    parent_of(id, "name", name).

.decl local_variable_declaration_statement(id: id, declaration: id)
.output local_variable_declaration_statement(IO=stdout)
local_variable_declaration_statement(id, declaration) :-
    name_of(id, "local_variable_declaration_statement"),
    parent_of(id, "declaration", declaration).

.decl local_variable_declaration(id: id, type: id, declarators: id_list, modifiers: id_list)
.output local_variable_declaration(IO=stdout)
local_variable_declaration(id, type, declarators, modifiers) :-
    name_of(id, "local_variable_declaration"),
    parent_of(id, "type", type),
    parent_of_list(id, "declarators", declarators),
    parent_of_list(id, "modifiers", modifiers).

.decl variable_declarator(id: id, name: id, initializer: id)
.output variable_declarator(IO=stdout)
variable_declarator(id, name, initializer) :-
    name_of(id, "variable_declarator"),
    parent_of(id, "name", name),
    parent_of(id, "initializer", initializer).

.decl class_instance_creation_expression(id: id, type_arguments: id_list, type: id, arguments: id_list, body: id_list)
class_instance_creation_expression(id, type_arguments, type, arguments, body) :-
    name_of(id, "class_instance_creation_expression"),
    parent_of_list(id, "type_arguments", type_arguments),
    parent_of(id, "type", type),
    parent_of_list(id, "arguments", arguments),
    parent_of_list(id, "body", body).

.decl class_type(id: id, name: id, type_arguments: id_list, annotations: id_list)
.output class_type(IO=stdout)
class_type(id, name, type_arguments, annotations) :-
    name_of(id, "class_type"),
    parent_of(id, "name", name),
    parent_of_list(id, "type_arguments", type_arguments),
    parent_of_list(id, "annotations", annotations).

.decl integer_literal(id: id)
integer_literal(id) :- name_of(id, "integer_literal").

.decl floating_point_literal(id: id)
floating_point_literal(id) :- name_of(id, "floating_point_literal").

.decl string_literal(id: id)
string_literal(id) :- name_of(id, "string_literal").

.decl expression_name(id: id, identifiers: id_list)
expression_name(id, identifiers) :-
    name_of(id, "expression_name"),
    parent_of_list(id, "identifiers", identifiers).

.decl identifier(id: id)
identifier(id) :- name_of(id, "identifier").

/* Common AST patterns
 ********************************/

.decl not_equals_null_expression(id: id, subject: id)
not_equals_null_expression(id, subject) :-
    not_equals_expression(id, _, _),
    parent_of(id, _, subject),
    parent_of(id, _, null),
    string_representation(null, "null"),
    subject != null.

/* Constant evaluation
 ********************************/

.decl evaluates_to_integer_value(id: id, value: number)
.output evaluates_to_integer_value(IO=stdout)
evaluates_to_integer_value(id, to_number(repr)) :-
    integer_literal(id),
    string_representation(id, repr).
evaluates_to_integer_value(id, left_value + right_value) :-
    addition_expression(id, left, right),
    evaluates_to_integer_value(left, left_value),
    evaluates_to_integer_value(right, right_value).
evaluates_to_integer_value(id, left_value * right_value) :-
    multiplication_expression(id, left, right),
    evaluates_to_integer_value(left, left_value),
    evaluates_to_integer_value(right, right_value).
evaluates_to_integer_value(id, left_value - right_value) :-
    subtraction_expression(id, left, right),
    evaluates_to_integer_value(left, left_value),
    evaluates_to_integer_value(right, right_value).

.decl evaluates_to_boolean_value(id: id, value: number)
evaluates_to_boolean_value(id, 0) :-
    string_representation(id, "false").
evaluates_to_boolean_value(id, 1) :-
    string_representation(id, "true").
evaluates_to_boolean_value(id, left_value land right_value) :-
    conditional_and_expression(id, left, right),
    evaluates_to_boolean_value(left, left_value),
    evaluates_to_boolean_value(right, right_value).
evaluates_to_boolean_value(id, left_value lor right_value) :-
    conditional_or_expression(id, left, right),
    evaluates_to_boolean_value(left, left_value),
    evaluates_to_boolean_value(right, right_value).
evaluates_to_boolean_value(id, 1) :-
    equals_expression(id, left, right),
    evaluates_to_integer_value(left, x),
    evaluates_to_integer_value(right, x).
evaluates_to_boolean_value(id, 0) :-
    equals_expression(id, left, right),
    evaluates_to_integer_value(left, x),
    evaluates_to_integer_value(right, y),
    x != y.

/* String representation
 ********************************/

.decl source_code(str: symbol)
.input source_code

.decl string_representation(id: id, str: symbol)
string_representation([name, A, B], substr(code, A, B - A)) :-
    ast_node([name, A, B]),
    source_code(code).

/* Declared variables
 ********************************/

.decl is_in_scope(identifier: symbol, at: id, type: id)
.output is_in_scope(IO=stdout)

/**
 * The scope of a local variable declaration in a block (ยง14.2) is the rest of
 * the block in which the declaration appears, starting with its own
 * initializer (ยง14.4) and including any further declarators to the right in
 * the local variable declaration statement.
 * https://docs.oracle.com/javase/specs/jls/se6/html/statements.html
 */

/* Make field declarations accessible in the methods of a class. */
is_in_scope(name_str, method_body, type) :-
    class_declaration(_, _, _, _, _, class_body),
    /* declared_at */
    list_contains(class_body, field),
    field_declaration(field, _, type, declarators),
    list_contains(declarators, declarator),
    variable_declarator(declarator, name, _),
    string_representation(name, name_str),
    /* available at */
    list_contains(class_body, method),
    method_declaration(method, _, _, method_body).

/* Make formal parameters accessible in the body of a method. */
is_in_scope(name_str, body, type) :-
    method_declaration(_, _, header, body),
    method_header(header, _, declarator, _),
    parent_of_list(declarator, "params", params),
    list_contains(params, param),
    formal_parameter(param, _, type, name),
    string_representation(name, name_str).

/* Make local variable declarations accessible in the succeeding
   statements */
is_in_scope(name_str, succeeding_statement, type) :-
    local_variable_declaration_statement(declaration_statement, declaration),
    local_variable_declaration(declaration, type, declarators, _),
    precedes(declaration_statement, succeeding_statement),
    list_contains(declarators, declarator),
    variable_declarator(declarator, name, _),
    string_representation(name, name_str).

/* Propagate scope of variables in the AST */
is_in_scope(name_str, descendant, type) :-
    is_in_scope(name_str, ancestor, type),
    ancestor_of(ancestor, descendant).

/* Output for user interface */
.decl is_in_scope_output(variable: symbol, type: symbol, start: number, end: number)
.output is_in_scope_output
is_in_scope_output(var, type_str, start, end) :-
    is_in_scope(var, id, type),
    ends_at(id, end),
    starts_at(id, start),
    string_representation(type, type_str).

/* Type checking
 ********************************/

.decl collection_type_name(str: symbol)
collection_type_name("ArrayList").
collection_type_name("Collection").
collection_type_name("LinkedList").
collection_type_name("List").
collection_type_name("Queue").
collection_type_name("Set").
collection_type_name("SortedSet").
collection_type_name("Stack").
collection_type_name("Vector").

.decl floating_point_type_name(str: symbol)
floating_point_type_name("float").
floating_point_type_name("double").

.decl atomic_class_type_name(str: symbol)
atomic_class_type_name("AtomicInteger").
atomic_class_type_name("AtomicBoolean").
atomic_class_type_name("AtomicLong").

.decl boxed_type_name(str: symbol)
boxed_type_name("Boolean").
boxed_type_name("Byte").
boxed_type_name("Character").
boxed_type_name("Float").
boxed_type_name("Integer").
boxed_type_name("Long").
boxed_type_name("Short").
boxed_type_name("Double").

/* Is type */

.decl is_collection_type(id: id)
is_collection_type(id) :-
    // TODO: Should take imports into consideration?
    class_type(id, name, _, _),
    string_representation(name, name_str),
    collection_type_name(name_str).

.decl is_exception_type(id: id)
is_exception_type(id) :-
    class_type(id, name, _, _),
    string_representation(name, name_str),
    match(".*Exception", name_str).

.decl is_string_type(id: id)
is_string_type(id) :-
    class_type(id, name, _, _),
    string_representation(name, "String").

.decl is_boxed_type(id: id)
is_boxed_type(id) :-
    class_type(id, name, _, _),
    string_representation(name, name_str),
    boxed_type_name(name_str).

.decl is_floating_point_type(id: id)
is_floating_point_type(id) :-
    class_type(id, name, _, _),
    string_representation(name, name_str),
    floating_point_type_name(name_str).

.decl is_atomic_class_type(id: id)
is_atomic_class_type(id) :-
    class_type(id, name, _, _),
    string_representation(name, name_str),
    atomic_class_type_name(name_str).

/* Has type */

.decl has_type(id: id, type: id)
.output has_type(IO=stdout)
has_type(id, type) :-
    identifier(id),
    string_representation(id, id_str),
    is_in_scope(id_str, id, type).
has_type(expr_name, type) :-
    expression_name(expr_name, _),
    string_representation(expr_name, expr_name_str),
    is_in_scope(expr_name_str, expr_name, type).

.decl has_floating_point_type(id: id)
has_floating_point_type(id) :- floating_point_literal(id).
has_floating_point_type(id) :- has_type(id, type), is_floating_point_type(type).

.decl has_string_type(id: id)
has_string_type(id) :- string_literal(id).
has_string_type(id) :- has_type(id, type), is_string_type(type).

.decl has_string_or_boxed_type(id: id)
has_string_or_boxed_type(id) :- has_type(id, type), is_boxed_type(type).
has_string_or_boxed_type(id) :- has_string_type(id).

.decl has_collection_type(id: id)
has_collection_type(id) :- has_type(id, type), is_collection_type(type).

.decl has_atomic_class_type(id: id)
has_atomic_class_type(id) :- has_type(id, type), is_atomic_class_type(type).

/* Rewrite rules
 ********************************/

.decl rewrite(message: symbol, from: id, to: symbol)
.output rewrite(IO=stdout)

#include "rules/1125.dl"
#include "rules/1132.dl"
#include "rules/1155.dl"
#include "rules/1596.dl"
#include "rules/2111.dl"
#include "rules/2204.dl"
#include "rules/2272.dl"
#include "rules/2293.dl"
#include "rules/3984.dl"
#include "rules/4973_use_equals_method.dl"
